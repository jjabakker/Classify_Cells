---
title: "Classify and Evaluate - All"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include = FALSE} 
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
# rm(list = ls())
set.seed(1234)
```

Make sure to set the knit directory to 'project directory' (which is the directory below 'Code')
Run command: rmarkdown::render("Caret_Predict.Rmd")


# Specify key use parameters

Options are:
  "Xin",                  "Xin",
  "Muraro",               "Muraro",
  "Baron_Human",          "Baron_Human",
  "Baron_Mouse",          "Baron_Mouse",
  "SegerStolpe",          "SegerStolpe",
  "Zhou",                 "Zhou",
  "Bo",                   "Bo",
  "Petropoulos1",         "Petropoulos1"
  
  
  "c_Muraro_Segerstolpe", "c_Muraro_Segerstolpe",
  "c_Xin_Segerstolpe",    "c_Xin_Segerstolpe",
  "c_Muraro_Xin",         "c_Muraro_Xin",
  "c_Muraro_Segerstolpe", "SegerStolpe",
  "c_Muraro_Segerstolpe", "Muraro",
  "c_Muraro_Xin",         "Muraro",
  "c_Muraro_Xin",         "Xin",
  "c_Xin_Segerstolpe",    "Xin",
  "c_Xin_Segerstolpe",    "Segerstolpe",

  "Muraro",               "SegerStolpe",
  "Muraro",               "Xin",
  "SegerStolpe",          "Muraro",
  "SegerStolpe",          "Xin",
  "Xin",                  "Muraro",
  "Xin",                  "SegerStolpe"

```{r}

# Specify all the pairs of datasets and models to evaluate

library(tidyverse)
to_review <- tribble(
  ~ModelData,             ~TestData,
  
  "Xin",                  "Xin",
  "Muraro",               "Muraro",
  "Baron_Human",          "Baron_Human",
  "Baron_Mouse",          "Baron_Mouse",
  "SegerStolpe",          "SegerStolpe",
  "Zhou",                 "Zhou",
  "Bo",                   "Bo",
  "Petropoulos1",         "Petropoulos1"
)

# Select preprocessing

preproc_method         <- "pp_pca"
preproc_method         <- "pp_no_pca"
preproc_method         <- "pp_log_pca"

preproc_method         <- "pp_log_pca"

# Specify which models you want to run

PREDICT_SVML           <- TRUE
PREDICT_SVMR           <- TRUE
PREDICT_RF             <- TRUE
PREDICT_GBM            <- TRUE
PREDICT_GLMNET         <- FALSE

```


```{r}

if  (FALSE) {
  to_review <- rowid_to_column(to_review, "nr")
  to_review <- as.data.frame(to_review)
  to_review
}

```

# Initialise

```{r, libraries, message=FALSE}

library(readr)
library(tidyverse)
library(gridExtra)
library(caret)
library(matrixStats)
library(GGally)

source("Code/Predict/predict_model_with_labels.R")
source("Code/Predict/read_model_and_data.R")

```


```{r, set preprocess options}

if (preproc_method == "pp_pca")  {
  log_preprocess   <- FALSE
  caret_preprocess_method <- c('scale', 'center', 'pca')
} else if (preproc_method == "pp_no_pca")  {
  log_preprocess   <- FALSE
  caret_preprocess_method <- c('scale', 'center')
} else if (preproc_method == "pp_log_pca")  {
  log_preprocess   <- TRUE
  caret_preprocess_method <- c('scale', 'center', 'pca')
}

```


```{r, path to set and report_out}

proj_path   <- file.path(".")
data_path   <- file.path(proj_path, "DataSets")
log_path    <- file.path(proj_path, "Logs")
rdata_path  <- file.path(proj_path, "rData")
config_path <- file.path(proj_path, "config")

# Initialise the report_out table
report_out <- data.frame(Method       = character(),
                         ModelData    = character(),
                         TestData     = character(),
                         Accuracy     = numeric(),
                         CorrAccuracy = numeric(),
                         Confidence   = numeric())

# Information of all the runs will be gathered in the class_summaries list  
class_summaries <- list()

```



# Read and Predict 


```{r, fig.width = 5}

sink(file.path(log_path, paste0(preproc_method, "_all_classify.txt")))

for (row in 1:nrow(to_review)) {
  
  # Set the data and model namde and read the data
  model_name      <- to_review[row, "ModelData"]
  dataset_name    <- to_review[row, "TestData"]
  
  ret             <- read_model_and_data(rdata_path, model_name, preproc_method)
  preproc_model   <- ret$model[["preproc_model"]]
  model_svmRadial <- ret$model[["model_svmRadial"]]
  model_svmLinear <- ret$model[["model_svmLinear"]]
  model_rf        <- ret$model[["model_rf"]]
  model_gbm       <- ret$model[["model_gbm"]]
  model_glmnet    <- ret$model[["model_glmnet"]]
  features_limit  <- ret$model[["features_limit"]]
  PCA_Threshold   <- ret$model[["PCA_Threshold"]]
  top_genes       <- ret$model[["top_genes"]]
  data            <- ret$data[["data"]]
  labels          <- ret$data[["labels"]]
  trainRowNumbers <- ret$data[["trainRowNumbers"]]

  if (log_preprocess) {
    data <- log(1 + data)
  }
  
  # In case the model and data set are the same, you do not want to predict on the whole dataset, but only on the part
  # that was not used for training. In that case eliminate the training records,
  if (model_name == dataset_name) {
    data   <- data[-trainRowNumbers,]
    labels <- labels[-trainRowNumbers,]
    labels <- as.data.frame(labels)
  }
  
  # Check if there are top genes missing in the dataset, and of so provide dummy values 
  missing_col <- setdiff(top_genes[1:features_limit], colnames(data))
  newcol = rep.int(0,dim(data)[1])
  if (length(missing_col) > 0) {
    for (i in 1:length(missing_col)) {
      data[ , missing_col[i]] = newcol
    }
    cat(sprintf("There were %s top %d features missing in the data datset.\n", length(missing_col), features_limit))
  } else {
    cat(sprintf("All top %d features were present in the data set.\n", features_limit))
  }
  
  if (PREDICT_SVMR && !is.null(model_svmRadial)) { 
    ret         <- predict_model_with_labels(method     = "SVMR",
                                           model        = model_svmRadial, 
                                           model_name   = model_name,
                                           dataset_name = dataset_name,
                                           data         = data, 
                                           labels       = labels, 
                                           report_out   = report_out)
    report_out <- ret$report_out 
  }
  
  if (PREDICT_SVML && !is.null(model_svmLinear)) { 
    ret         <- predict_model_with_labels(method     = "SVML",
                                           model        = model_svmLinear, 
                                           model_name   = model_name,
                                           dataset_name = dataset_name,
                                           data         = data, 
                                           labels       = labels, 
                                           report_out   = report_out)   
    report_out <- ret$report_out    
  }
  
  if (PREDICT_RF && !is.null(model_rf)) { 
    ret         <- predict_model_with_labels(method     = "RF",
                                           model        = model_rf, 
                                           model_name   = model_name,
                                           dataset_name = dataset_name,
                                           data         = data, 
                                           labels       = labels, 
                                           report_out   = report_out) 
    report_out <- ret$report_out 
  }
  
  if (PREDICT_GBM && !is.null(model_gbm)) { 

    ret        <- predict_model_with_labels(method       = "GBM",
                                            model        = model_gbm, 
                                            model_name   = model_name,
                                            dataset_name = dataset_name,
                                            data         = data, 
                                            labels       = labels, 
                                            report_out   = report_out) 
    report_out <- ret$report_out 
  }
 
  if (PREDICT_GLMNET && !is.null(model_glmnet)) { 
    ret        <- predict_model_with_labels(method       = "PREDICT_GLMNET",
                                            model        = model_glmnet, 
                                            model_name   = model_name,
                                            dataset_name = dataset_name,
                                            data         = data, 
                                            labels       = labels, 
                                            report_out   = report_out)      
    report_out <- ret$report_out 
  }
}

sink()

```
# Report out

```{r, fig.width = 6}

print(class_summaries)

```


```{r, fig.width = 5}

plotdata <- report_out[as.character(report_out$TestData) == as.character(report_out$ModelData),]
ggplot(report_out) +
  geom_point(aes(x = medianF1, y = Confidence, col = TestData)) +
  xlab("Median F1") +
  facet_wrap( ~ Method) +
  scale_x_continuous(limits = c(0, 1)) +
  scale_y_continuous(limits = c(0, 1)) +
  theme_light()

```

```{r, fig.width = 5}

plotdata <- report_out[as.character(report_out$TestData) == as.character(report_out$ModelData),]
ggplot(plotdata) +
  geom_point(aes(x = CorrAccuracy, y = Confidence, col = TestData)) +
  facet_wrap( ~ Method) +
  scale_x_continuous(limits = c(0, 1)) +
  scale_y_continuous(limits = c(0, 1)) +
  theme_light() +
  labs(x = "Corrected Accuracy")

```

```{r, fig.width = 5}

plotdata <- report_out[as.character(report_out$TestData) == as.character(report_out$ModelData),]
ggplot(plotdata) +
  geom_point(aes(x = medianF1, y = Confidence, col = Method)) +
  xlab("Median F1") +
  scale_x_continuous(limits = c(0, 1)) +
  scale_y_continuous(limits = c(0, 1)) +
  facet_wrap( ~ TestData) +
  theme_light()

```

```{r}

plotdata <- report_out[report_out$TestData == report_out$ModelData,]
ggplot(plotdata) +
  geom_point(aes(x = Accuracy, y = CorrAccuracy, col = Method)) +
  theme_light() +
  coord_fixed(ratio = 1) +
  scale_x_continuous(limits = c(0, 1)) +
  scale_y_continuous(limits = c(0, 1)) +
  ggtitle("The change in correctness when confidence limit is applied") +
  labs(y = "Corrected Accuracy")

```
```{r}

plotdata <- report_out[report_out$TestData == report_out$ModelData,]
colnames(plotdata)[4] = "Uncorrected"
colnames(plotdata)[5] = "Corrected"

ggparcoord(plotdata, 
           columns=4:5,
           groupColumn = 1,
           scale="globalminmax",
           title = "Change in accuracy after applying the confidence limit",
           showPoints = TRUE) +
   theme_light() +
   labs(y = "Accuracy") + 
   labs(x = "")

```


```{r, fig.width = 5}

# plotdata <- report_out[report_out$ModelData == "c_Muraro_Segerstolpe",]
# ggplot(plotdata) +
#   geom_point(aes(x = Accuracy, y = Confidence, col = TestData)) +
#   facet_wrap( ~ Method) +
#   ggtitle("Various data sets predicted with model based on combined Muraro-Segerstolpe") +
#   theme_light()

```

```{r, fig.width = 5}

# plotdata <- report_out[report_out$ModelData == "c_Muraro_Xin",]
# ggplot(plotdata) +
#   geom_point(aes(x = Accuracy, y = Confidence, col = TestData)) +
#   facet_wrap( ~ Method) +
#   ggtitle("Various data sets predicted with model based on combined Muraro-Xin") +
#   theme_light()

```



## Generate the results table 

### First check for missing items

```{r}

d <- unique(report_out$TestData)
m <- unique(report_out$Method)
for (i in 1:length(d)) {
  for (j in 1:length(m)) {
    r <- report_out %>%
      filter(TestData == d[i] & Method == m[j]) %>%
      select(Method, TestData)
    if ( dim(r)[1] == 0) {
      missing <- data.frame(Method       = m[j], 
                            TestData     = d[i], 
                            ModelData    = d[i], 
                            Accuracy     = NA,
                            CorrAccuracy = NA,
                            Confidence   = NA,
                            medianF1     = NA,
                            meanF1       = NA
                            )
      report_out <- rbind(report_out, missing)
    }
  }
} 


report_out <- report_out %>% 
  arrange(TestData, Method)

```


### With median F1

```{r}

report_out

ro <- report_out %>%
  select(Method, TestData, medianF1)

d <- unique(ro$TestData)

ro1 <- ro %>%
  filter(TestData == d[1]) %>%
  select(medianF1) 
colnames(ro1) <- d[1]

# For now this only worlks, when you have at least two dataset

for (i in 2:length(d)) {
  ro2 <- ro %>%
    filter(TestData == d[i]) %>%
    select(medianF1) 
  colnames(ro2) <- d[i]
  ro1 <- cbind(ro1, ro2)
} 
rownames(ro1) = unique(ro$Method)

ro1

```


```{r}

# To create the plot table you need to run this script three times changing the preproc_method
# At the start of the cyle delete combined_plot_data if it ecists

plot_data <- report_out %>%
  select(Method, TestData, medianF1) 
plot_data$PreProc <- preproc_method
plot_data <- plot_data %>%
  select(Method, TestData, PreProc, medianF1)
if (exists("combined_plot_data")) {
  combined_plot_data <- rbind(combined_plot_data, plot_data)
} else {
  combined_plot_data <- plot_data
}

if (FALSE) {
  save(combined_plot_data, file = file.path(rdata_path, "combined_plot.rData"))
}
```


```{r}

colr <- RColorBrewer::brewer.pal(9, "GnBu")
cpd  <- combined_plot_data

cpd <- cpd %>%
  mutate (PreProc  = replace(PreProc, PreProc == "pp_no_pca" , "No PCA")) %>%
  mutate (PreProc  = replace(PreProc, PreProc == "pp_pca" ,    "Just PCA")) %>%  
  mutate (PreProc  = replace(PreProc, PreProc == "pp_log_pca", "Log and PCA"))
    
ggplot(cpd, aes(x = Method, y = medianF1, fill = as.factor(Method))) +
  geom_bar(stat= "identity", width = 0.3) +
  facet_grid(vars(TestData), vars(PreProc)) +
  scale_fill_manual(values = c(colr[2], colr[4], colr[6], colr[7]) ) +
  ylim(0, 1) +
  ylab("Median F1") +
  theme_light() +
  theme(legend.title=element_blank()) 
```

### With mean F1

```{r}

if (FALSE) {
  report_out
  
  ro <- report_out %>%
    select(Method, TestData, meanF1)
  
  d <- unique(ro$TestData)
  
  ro1 <- ro %>%
    filter(TestData == d[1]) %>%
    select(meanF1) 
  colnames(ro1) <- d[1]
  
  for (i in 2:length(d)) {
    ro2 <- ro %>%
      filter(TestData == d[i]) %>%
      select(meanF1) 
    colnames(ro2) <- d[i]
    ro1 <- cbind(ro1, ro2)
  }
  rownames(ro1) = unique(ro$Method)
  
  ro1
}

```


### With accuracy

```{r}

if (FALSE) {
  report_out
  
  ro <- report_out %>%
    select(Method, TestData, Accuracy)
  
  d <- unique(ro$TestData)
  
  ro1 <- ro %>%
    filter(TestData == d[1]) %>%
    select(Accuracy) 
  colnames(ro1) <- d[1]
  
  for (i in 2:length(d)) {
    ro2 <- ro %>%
      filter(TestData == d[i]) %>%
      select(Accuracy) 
    colnames(ro2) <- d[i]
    ro1 <- cbind(ro1, ro2)
  }
  rownames(ro1) = unique(ro$Method)
  
  ro1
}

```

